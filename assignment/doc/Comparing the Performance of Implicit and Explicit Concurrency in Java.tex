\documentclass[]{report}
\usepackage{listings}


% Title Page
\title{Comparing the Performance of Implicit and Explicit Concurrency in Java}
\author{Dominic Rathbone}


\begin{document}
\maketitle

\section*{Introduction}
In order to compare the effects of concurrency in Java on performance, A test program was created that compared various implementations of concurrency, implicit and explicit, to two baseline non-concurrent implementations. These implementations performed a mathematical operations on a set of integers derived from the user inputting a start and end number at launch. This operation consisted of finding all the mersenne primes in the set. Within this program, time recorded in nano seconds was used as a benchmark in order to compare these implementations to each other. Although there are other variables that could be used in conjunction that may give a more detailed result, using time gives clear and simple results to draw conclusions from. The time was taken before and after each implementation ran over the set and then the total run time was derived from them. In order to compare them with ease, a ratio derived from dividing the total time of the baseline implementation by the total time of concurrent implementation is outputted to csv files. To run the programs, I am using a ThinkPad laptop running Fedora with a quad-core 2.50GHz i5-2520M CPU and 8 gigabytes of RAM. as well as a Gaming PC running Windows 7 with a quad-core 3.50GHz i5 4690K and 8 gigabytes of RAM.

\section{Non-concurrent Approach}
The non-concurrent approach runs the operations sequentially, running over the sequence of integers with a for statement and incrementing a counter every time a prime number is found. This is used as the baseline to compare the implicit and explicit concurrent approaches to.

\section{Raw Multithreaded Approach}
The first explicitly concurrent implementation uses raw threads to run the operations over the sequence of numbers. This was attempted in two ways. First of all, to make the test fairer, I produced an implementation that spawned a new thread for every number in the sequence (see appendix A), similar to how a parallel stream would split a stream of numbers into multiple parallel substreams. On testing this implementation, it was revealed that this would not be an efficient way to approach concurrency because  as the sequence of numbers became larger, it would become extremely slow. This was due to the lack of thread management such as a queue or limit to how many threads should be started at once meaning the machine was being flooded with threads. 

As a result of this, the implementation was revised and it was decided that the best way to approach this was to split the sequence of numbers down into smaller sequences using the number of cores with one thread for each sequence. This would mean that although each CPU core had to process with a larger sequence of numbers per thread, the number of threads and the overhead associated with them was lower which meant the time was significantly faster.

\subsubsection{Windows 7 PC}
 
\section{Thread Pooled Approach}
The second explicitly concurrent implementation
\subsection{Performance}
\subsubsection{Fedora Laptop}
\subsubsection{Windows 7 PC}

\section{Serial Stream Approach}
\subsection{Performance}
\subsubsection{Fedora Laptop}
\subsubsection{Windows 7 PC}

\section{Parallel Stream Approach}
\subsection{Performance}
\subsubsection{Fedora Laptop}
\subsubsection{Windows 7 PC}


\appendix
\chapter{}
\begin{figure}[h!]
	\caption{Non-concurrent}
	\begin{lstlisting}[language=Java,frame=single]

	\end{lstlisting}
\end{figure}

\chapter{}
\begin{figure}[h!]
	\caption{Multi-threaded 1}
	\begin{lstlisting}[language=Java,frame=single]

	\end{lstlisting}
\end{figure}

\begin{figure}[h!]
	\caption{Multi-threaded 2}
	\begin{lstlisting}[language=Java,frame=single]

	\end{lstlisting}
\end{figure}

\chapter{}
\begin{figure}[h!]
	\caption{Thread Pool}
	\begin{lstlisting}[language=Java,frame=single]
public void run() {
	ExecutorService executor =
			Executors.newFixedThreadPool(6);
	executor.execute(new ThreadA(start, end));
	executor.execute(new ThreadB(start, end));
	executor.execute(new ThreadC(start, end));
	executor.execute(new ThreadD(start, end));
	executor.shutdown();
	while(!executor.isTerminated()) {
	}
}
	\end{lstlisting}
\end{figure}

\chapter{}
\begin{figure}[h!]
	\caption{Serial Stream}
	\begin{lstlisting}[language=Java,frame=single]
public void run() {
	Stream
	.iterate(start, i -> i++)
	.limit(end)
	.filter(i -> isFactor(i, end))
	.filter(i -> isPrime(i))
	.filter(i -> isMersenne(i))
	.filter(i -> isPerfect(i))
	.close();
}
	\end{lstlisting}
\end{figure}
\chapter{}
\begin{figure}[h!]
	\caption{Parallel Stream}
	\begin{lstlisting}[language=Java,frame=single]
public void run() {
    Stream
    .iterate(start, i -> i++)
    .limit(end)
    .filter(i -> isFactor(i, end))
    .filter(i -> isPrime(i))
    .filter(i -> isMersenne(i))
    .filter(i -> isPerfect(i))
    .close();
}
	\end{lstlisting}
\end{figure}
\end{document}          
